<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/Suggester.js - Suggester</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Suggester"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.2.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Suggester.html">Suggester</a></li>
            
                <li><a href="../classes/Suggester.Tag.html">Suggester.Tag</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/jQuery.html">jQuery</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/Suggester.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function (factory) {
	// AMD compatibility
	// https://github.com/umdjs/umd/blob/6c10fc0af1e1692cf430c9eb7f530d6b5a5d758b/jqueryPlugin.js
	if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {
		// AMD environment
		define([&#x27;jquery&#x27;], factory);
	} else {
		// Browser environment
		factory(jQuery);
	}
}(function($) {
	&quot;use strict&quot;;
	/**
	 * @module jQuery
	 */
	// get our document once
	var $document = $(document);
	// Our true constructor function. See jQuery.Suggester.prototype.initialize for documentation
	$.Suggester = function() {
		if (arguments[0] === $.Suggester.doSubclass) {
			return;
		}
		this.initialize.apply(this, Array.prototype.slice.call(arguments));
	};
	/**
	 * Default options. Change these to globally change the default options
	 * See {{#crossLink &quot;Suggester/constructor:method&quot;}}constructor{{/crossLink}} for documentation on each option
	 * @property {Object} defaultOptions
	 * @static
	*/
	$.Suggester.defaultOptions = {
		data: false,
		valueProperty: &quot;value&quot;,      
		labelProperty: &quot;value&quot;,      
		searchProperties: [&quot;value&quot;],
		matchAt: &#x27;anywhere&#x27;,
		caseSensitive: false,
		dataUrl: false,
		dataType: &#x27;json&#x27;,
		fly: &#x27;down&#x27;,
		suggListPosition: &#x27;relative&#x27;,
		multiselect: true,
		preventDuplicates: true,
		omitAlreadyChosenItems: true,
		minChars: 3,
		keyDelay: 400,
		addOnComma: true,
		addOnTab: true,
		addOnSemicolon: false,
		addOnSubmit: true,
		addOnBlur: true,
		submitOnEnter: false,
		inputSize: &#x27;auto&#x27;,
		placeholder: &#x27;&#x27;,
		emptyText: &#x27;(Type a comma to create a new item)&#x27;,
		prompt: false,
		maxSuggestions: 10,
		addHiddenInputs: true,
		hiddenName: null,
		hightlightSubstring: true,		
		template:
		&#x27;&lt;div class=&quot;sugg-widget&quot;&gt;&#x27; + // this.$widget
			&#x27;&lt;ul class=&quot;sugg-box&quot;&gt;&#x27; + // this.$box
				&#x27;&lt;li class=&quot;sugg-box-item sugg-tag&quot;&gt;&#x27; + // this.$tagTemplate
					&#x27;&lt;span class=&quot;sugg-label&quot;&gt;TAG TEXT GOES HERE&lt;/span&gt;&lt;span class=&quot;sugg-remove&quot; title=&quot;Click to remove&quot;&gt;&amp;times;&lt;/span&gt;&#x27; +
				&#x27;&lt;/li&gt;&#x27; + 
				&#x27;&lt;li class=&quot;sugg-box-item sugg-input-wrapper&quot;&gt;&#x27; + // this.$inputWrapper
					&#x27;&lt;input type=&quot;text&quot; class=&quot;sugg-input&quot; value=&quot;&quot; autocomplete=&quot;off&quot; /&gt;&#x27; + // this.$input
				&#x27;&lt;/li&gt;&#x27; +
			&#x27;&lt;/ul&gt;&#x27; +
			&#x27;&lt;div class=&quot;sugg-list-wrapper&quot;&gt;&#x27; + 
				&#x27;&lt;ul class=&quot;sugg-list&quot; style=&quot;display:none&quot;&gt;&#x27; + // this.$suggList
					&#x27;&lt;li class=&quot;sugg-item {record.cssClass}&quot;&gt;{record.value}&lt;/li&gt;&#x27; + // innerHTML is used as this.listItemTemplate unless options.listItemTemplate is set
					&#x27;&lt;li class=&quot;sugg-empty&quot;&gt;&lt;/li&gt;&#x27; + // this.$empty
					&#x27;&lt;li class=&quot;sugg-prompt&quot;&gt;&lt;/li&gt;&#x27; + // this.$prompt
				&#x27;&lt;/ul&gt;&#x27; +
			&#x27;&lt;/div&gt;&#x27; +
		&#x27;&lt;/div&gt;&#x27;,
		listItemTemplate: null,
		theme: &#x27;coolblue&#x27;
	};
	$.Suggester.prototype = {
		/**
		 * The current options. Starts with value given in constructor
		 * @property {Object} options
		 *   @param {Array|Boolean} [options.data=false]  Initial data to use for suggestions
		 *   @param {String} [options.valueProperty=&quot;value&quot;]  The name of object property that should be used as the tag&#x27;s value. Only applicable when options.data is set
		 *   @param {String} [options.labelProperty=&quot;value&quot;]  The name of object property that should be used as the tag&#x27;s display text. Only applicable when options.data is set
		 *   @param {Array} [options.searchProperties=Array(&quot;value&quot;)]  The array of object property names that should be searched when generating suggestions. Only applicable when options.data is set
		 *   @param {String|Number} [options.matchAt=&quot;anywhere&quot;]  Where to match when finding suggestions. It can be &quot;anywhere&quot;, &quot;start&quot;, &quot;end&quot; or an integer. Only applicable when options.data is set
		 *   @param {Boolean} [options.caseSensitive=false]  If true, find matches regardless of case. Only applicable when options.data is set. Only applicable when options.data is set
		 *   @param {String} [options.dataUrl=false]  Url to call to get json or jsonp results. Use %s to indicate where search text should be inserted. e.g. &quot;http://example.com/myjson?query=%s&quot; or &quot;http://example.com/myjsonp?query=%s&amp;callback=%s&quot;
		 *   @param {String} [options.dataType=&quot;json&quot;]  Can be &quot;json&quot; or &quot;jsonp&quot;. If json, options.dataUrl needs to be in the format &quot;http://example.com/myjsonp?query=%s&amp;mycallback=%s&quot;. To handle xml, you&#x27;ll need to register BeforeFetch and AfterFetch handlers or overwrite the fetchResults method
		 *   @param {String} [options.fly=&quot;down&quot;]  Which way should the suggestion box fly. If &quot;up&quot;, the suggestion box will appear before the input box in the DOM tree. A css class of &quot;sugg-fly-up&quot; or &quot;sugg-fly-down&quot; is applied to the widget element based on this value
		 *   @params {String} [options.suggListPosition=&quot;relative&quot;]  If &quot;absolute&quot;, the suggestion box will be appended to &lt;body&gt; and positioned and sized each time it is opened. This is useful for widgets within table elements
		 *   @param {Boolean} [options.multiselect=true]  If true, allow multiple tags
		 *   @param {Boolean} [options.preventDuplicates=true]  If true, the first tag will be removed when a duplicate is typed in
		 *   @param {Boolean} [options.omitAlreadyChosenItems=true]  If true, don&#x27;t suggest items that have already been chosen as tags. Only applicable when options.data is set
		 *   @param {Number} [options.minChars=3]  The minimum number of characters a user must type before the suggestion box will appear. If 0, show choices when input is simply focused (like a faux select widget)
		 *   @param {Number} [options.keyDelay=400]  The number of milliseconds between keystrokes before the suggestion lookup begins
		 *   @param {Boolean} [options.addOnComma=true]  If true, typing a comma will add the current text as a tag
		 *   @param {Boolean} [options.addOnTab=true]  If true, typing a tab will add the current text as a tag
		 *   @param {Boolean} [options.addOnSemicolon=false]  If true, typing a semicolon will add the current text as a tag
		 *   @param {Boolean} [options.addOnSubmit=true]  If true, add tag on submit if user has entered text but not typed comma or tab
		 *   @param {Boolean} [options.addOnBlur=true]  If true, add tag on blur if user has entered text but not typed comma or tab
		 *   @param {Boolean} [options.submitOnEnter=false]  If false, prevent the form from submitting when the user presses enter on the empty input
		 *   @param {String} [options.inputSize=auto]  Manually set the input size property to a certain width. If auto, set size to text width
		 *   @param {String} [options.placeholder]  Placeholder text to display when no tags are present. e.g. &quot;Enter tags...&quot;
		 *   @param {String} [options.emptyText]  Message to show when there are no suggestions - default is &quot;(Type a comma to create a new item)&quot;
		 *   @param {String} [options.prompt]  Message to display in suggestion list when below min char length
		 *   @param {Number} [options.maxSuggestions=10]  Only display this many suggestions
		 *   @param {Boolean} [options.addHiddenInputs=true]  If true, also add a hidden input for each tag (fieldname_tag[]) for easier server-side processing (See options.hiddenName to create a custom name)
		 *   @param {String} [options.hiddenName]  The name to use for hidden elements (defaults to the original input&#x27;s name plus &quot;_tags[]&quot;)
		 *   @param {Boolean} [options.highlightSubstring=true]  If true, wrap first matching substring in each suggestion with &lt;strong class=&quot;sugg-match&quot;&gt;&lt;/strong&gt;
		 *   @param {String} [options.template]  The html used to generate the widget. You can add more markup, change tag names, or add css classes, but all the sugg-* classes need to remain. See below for default.
	
	&lt;div class=&quot;sugg-widget&quot;&gt; &lt;!-- this.$widget --&gt;		
		&lt;ul class=&quot;sugg-box&quot;&gt; &lt;!-- this.$box --&gt;
			&lt;li class=&quot;sugg-box-item sugg-tag&quot;&gt;  &lt;!-- this.$tagTemplate --&gt;
				&lt;span class=&quot;sugg-label&quot;&gt;TAG TEXT GOES HERE&lt;/span&gt;&lt;span class=&quot;sugg-remove&quot; title=&quot;Click to remove&quot;&gt;&amp;times;&lt;/span&gt;
			&lt;/li&gt;
			&lt;li class=&quot;sugg-box-item sugg-input-wrapper&quot;&gt; &lt;!-- this.$inputWrapper --&gt;
				&lt;input type=&quot;text&quot; class=&quot;sugg-input&quot; value=&quot;&quot; autocomplete=&quot;off&quot; /&gt; &lt;!-- this.$input --&gt;
			&lt;/li&gt;
		&lt;/ul&gt;
		&lt;div class=&quot;sugg-list-wrapper&quot;&gt;
			&lt;ul class=&quot;sugg-list&quot; style=&quot;display:none&quot;&gt; &lt;!-- this.$suggList --&gt;
				&lt;li class=&quot;sugg-item {record.cssClass}&quot;&gt;{record.value}&lt;/li&gt; &lt;!-- innerHTML is used as this.listItemTemplate unless options.listItemTemplate is set --&gt;
				&lt;li class=&quot;sugg-empty&quot;&gt;&lt;/li&gt; &lt;!-- this.$empty --&gt;
				&lt;li class=&quot;sugg-prompt&quot;&gt;&lt;/li&gt; &lt;!-- this.$prompt --&gt;
			&lt;/ul&gt;
		&lt;/div&gt;
	&lt;/div&gt;
		
		 *   @param {String} [options.listItemTemplate] Override the .sugg-item element in options.template
		 *   @param {String} [options.theme=&quot;coolblue&quot;]  The css class to add to widget (e.g. &quot;sugg-theme-coolblue&quot;). The following themes come predefined in the CSS: &quot;coolblue&quot;, &quot;faceblue&quot;, &quot;graybox&quot;, &quot;grayred&quot;
		 *   @param {Function} [options.onInitialize]  Add a {{#crossLink &quot;Suggester/Initialize:event&quot;}}Initialize event{{/crossLink}}
		 *   @param {Function} [options.onChange]  Add a {{#crossLink &quot;Suggester/Change:event&quot;}}Change event{{/crossLink}}
		 *   @param {Function} [options.onBeforeAdd]  Add a {{#crossLink &quot;Suggester/BeforeAdd:event&quot;}}BeforeAdd event{{/crossLink}}
		 *   @param {Function} [options.onBeforeAjax]  Add a {{#crossLink &quot;Suggester/BeforeAjax:event&quot;}}BeforeAjax event{{/crossLink}}
		 *   @param {Function} [options.onBeforeClose]  Add a {{#crossLink &quot;Suggester/BeforeClose:event&quot;}}BeforeClose event{{/crossLink}}
		 *   @param {Function} [options.onBeforeFetch]  Add a {{#crossLink &quot;Suggester/BeforeFetch:event&quot;}}BeforeFetch event{{/crossLink}}
		 *   @param {Function} [options.onBeforeFilter]  Add a {{#crossLink &quot;Suggester/BeforeFilter:event&quot;}}BeforeFilter event{{/crossLink}}
		 *   @param {Function} [options.onBeforeFormat]  Add a {{#crossLink &quot;Suggester/BeforeFormat:event&quot;}}BeforeFormat event{{/crossLink}}
		 *   @param {Function} [options.onBeforeHandleKey]  Add a {{#crossLink &quot;Suggester/BeforeHandleKey:event&quot;}}BeforeHandleKey event{{/crossLink}}
		 *   @param {Function} [options.onBeforeMove]  Add a {{#crossLink &quot;Suggester/BeforeMove:event&quot;}}BeforeMove event{{/crossLink}}
		 *   @param {Function} [options.onBeforeOpen]  Add a {{#crossLink &quot;Suggester/BeforeOpen:event&quot;}}BeforeOpen event{{/crossLink}}
		 *   @param {Function} [options.onBeforeRemove]  Add a {{#crossLink &quot;Suggester/BeforeRemove:event&quot;}}BeforeRemove event{{/crossLink}}
		 *   @param {Function} [options.onBeforeRender]  Add a {{#crossLink &quot;Suggester/BeforeRender:event&quot;}}BeforeRender event{{/crossLink}}
		 *   @param {Function} [options.onBeforeSave]  Add a {{#crossLink &quot;Suggester/BeforeSave:event&quot;}}BeforeSave event{{/crossLink}}
		 *   @param {Function} [options.onBeforeSubmit]  Add a {{#crossLink &quot;Suggester/BeforeSubmit:event&quot;}}BeforeSubmit event{{/crossLink}}
		 *   @param {Function} [options.onBeforeSuggest]  Add a {{#crossLink &quot;Suggester/BeforeSuggest:event&quot;}}BeforeSuggest event{{/crossLink}}
		 *   @param {Function} [options.onAfterAdd]  Add a {{#crossLink &quot;Suggester/AfterAdd:event&quot;}}AfterAdd event{{/crossLink}}
		 *   @param {Function} [options.onAfterAjax]  Add a {{#crossLink &quot;Suggester/AfterAjax:event&quot;}}AfterAjax event{{/crossLink}}
		 *   @param {Function} [options.onAfterClose]  Add a {{#crossLink &quot;Suggester/AfterClose:event&quot;}}AfterClose event{{/crossLink}}
		 *   @param {Function} [options.onAfterFetch]  Add a {{#crossLink &quot;Suggester/AfterFetch:event&quot;}}AfterFetch event{{/crossLink}}
		 *   @param {Function} [options.onAfterFilter]  Add a {{#crossLink &quot;Suggester/AfterFilter:event&quot;}}AfterFilter event{{/crossLink}}
		 *   @param {Function} [options.onAfterFormat]  Add a {{#crossLink &quot;Suggester/AfterFormat:event&quot;}}AfterFormat event{{/crossLink}}
		 *   @param {Function} [options.onAfterHandleKey]  Add a {{#crossLink &quot;Suggester/AfterHandleKey:event&quot;}}AfterHandleKey event{{/crossLink}}
		 *   @param {Function} [options.onAfterMove]  Add a {{#crossLink &quot;Suggester/AfterMove:event&quot;}}AfterMove event{{/crossLink}}
		 *   @param {Function} [options.onAfterOpen]  Add a {{#crossLink &quot;Suggester/AfterOpen:event&quot;}}AfterOpen event{{/crossLink}}
		 *   @param {Function} [options.onAfterRemove]  Add a {{#crossLink &quot;Suggester/AfterRemove:event&quot;}}AfterRemove event{{/crossLink}}
		 *   @param {Function} [options.onAfterSave]  Add a {{#crossLink &quot;Suggester/AfterSave:event&quot;}}AfterSave event{{/crossLink}}
		 *   @param {Function} [options.onAfterSuggest]  Add a {{#crossLink &quot;Suggester/AfterSuggest:event&quot;}}AfterSuggest event{{/crossLink}}
		 *   @example
	
	// EXAMPLE TEMPLATE CONFIG		
	// change uls to divs and lis to spans
	options.template = $.Suggester.defaultOptions.template
		.replace(/&lt;(\/)?ul/g, &#x27;&lt;$1div&#x27;)
		.replace(/&lt;(\/)?li/g, &#x27;&lt;$1span&#x27;)
	;
	// custom list item template
	options.listItemTemplate = &#x27;&lt;li class=&quot;sugg-item&quot;&gt;{record.lname}, {record.fname} ({record.email})&lt;/li&gt;&#x27;;	
	
		 */
		/**
		 * The input used to make the widget
		 * @property {jQuery} $originalInput
		 */		
		/**
		 * Array of static data used instead of an ajax call
		 * @property {Object[]} data 
		 */
		/**
		 * An array of Suggester.Tag objects
		 * @property {Suggester.Tag[]} tags
		 */
		/**
		 * The name to use for hidden elements (defaults to the original input&#x27;s name plus &quot;_tags[]&quot;)
		 * @property {String} hiddenName
		 */
		/**
		 * The tag that is selected for deletion
		 * @property {jQuery} $focusedTag
		 */
		/**
		 * The item currently selected in the suggestion box
		 * @property {jQuery} $currentItem
		 */
		/**
		 * The publish and subscribe handle - equal to $(this)
		 * @property {jQuery} pubsub
		 */
		/**
		 * The element that wraps the widget
		 * @property {jQuery} $widget
		 */
		/**
		 * The container that holds the chosen tags
		 * @property {jQuery} $box
		 */
		/**
		 * The tag element that is cloned to make new tags
		 * @property {jQuery} $tagTemplate
		 */
		/**
		 * The input that users type in
		 * @property {jQuery} $input
		 */
		/**
		 * The container for the input
		 * @property {jQuery} $inputWrapper
		 */
		/**
		 * The suggestion list element
		 * @property {jQuery} $suggList
		 */
		/**
		 * The element that is positioned relatively to hold the absolutely positioned suggestion list
		 * @property {jQuery} $suggListWrapper
		 */
		/**
		 * The element enclosing the empty text
		 * @property {jQuery} $empty
		 */
		/**
		 * The element enclosing the prompt
		 * @property {jQuery} $prompt
		 */
		/**
		 * The html to use for suggestion list items
		 * @property {String} listItemTemplate
		 */
		/**
		 * The search term we are currently searching for
		 * @property {String} _searchTerm
		 */
		/**
		 * The text in the input box that will be used to fetch results (i.e. what the user just typed)
		 * @property {String} _text
		 */
		/**
		 * The jQuery XHR object used initilized for fetching data - http://api.jquery.com/jQuery.ajax/#jqXHR
		 * @property {jqXHR} _jqXHR
		 */
		/**
		 * @class Suggester
		 * @constructor
		 * @example

	// Instantiate the OOP way
	var instance = new $.Suggester(&#x27;selector&#x27;, options)
		
	// Instantiate the jQuery way
	$(&#x27;selector&#x27;).suggester(options);
	// call methods on the instance
	$(&#x27;selector&#x27;).suggester(&#x27;method&#x27;, arg1, arg2);
	// initialize and get back instance
	var instance = $(&#x27;selector&#x27;).suggester(&#x27;getInstance&#x27;);

		 * @param {String|jQuery|HTMLElement} $textInput  The input element to convert into a widget
		 * @param {Object} [options=Suggester.defaultOptions] See {{#crossLink &quot;Suggester/options:property&quot;}}options property{{/crossLink}} for full documentation
		 */
		initialize: function($textInput, options) {
			// This is the original text input given
			this.$originalInput = $($textInput);
			this.$form = $(this.$originalInput.prop(&#x27;form&#x27;));
			// Bail because original input already has an instance .data(&#x27;SuggesterInstance&#x27;)
			if (this.$originalInput.data(&#x27;SuggesterInstance&#x27;)) {
				return this;
			}
			// register our instance
			$.Suggester.instances.push(this);
			if (this.$originalInput.length === 0) {
				// no input found. User could explicitly call initialize later
				// if not, there will likely be errors
				return this;
			}
			// TODO: allow input to be a select
			// our options are default options plus given options
			this._processOptions(options);
			// the preloaded list of suggestion records
			this.setData(this.options.data || []);    
			// a collection of tags and tag data
			this.tags = [];
			// the name given to the hidden $input elements
			this.hiddenName = this.options.hiddenName || this.$originalInput.attr(&#x27;name&#x27;) + &#x27;_tags[]&#x27;;
			// the tag that is clicked to prepare for deletion
			this.$focusedTag = false;
			// the currently selected suggestion
			this.$currentItem = false;
			// setup our pubsub system
			this._setupPubsub();
			// render our widget
			this._render();
			// setup event handlers
			this._setupListeners();
			// we&#x27;re all done
			/**
			 * Called after widget is initialized and rendered
			 * @event Initialize
			 */			
			this.publish(&#x27;Initialize&#x27;);
			return this;
		},
		/**
		 * Completely remove Suggester widget and replace with original input box (with values populated)
		 * @method destroy
		 * @param {Object} [options]
		 *    @param {Boolean} [options.keepHiddenInputs=false]  If true, append all hidden inputs after the original input
		 * @return {jQuery}  The original input
		 */
		destroy: function(options) {
			options = options || {};
			// &quot;un&quot;-render; this.$originalInput should be already populated
			this.$originalInput.insertBefore(this.$widget).show();
			this.$originalInput.removeData(&#x27;SuggesterInstance&#x27;);
			if (options.keepHiddenInputs) {
				this.$widget.find(&#x27;input[type=hidden]&#x27;).insertBefore(this.$widget);
			}
			this.tags = [];
			this.data = [];
			this.$widget.empty().remove();
			// unregister our instance
			var sugg = this;
			$.each($.Suggester.instances, function(i) {
				if (sugg === this) {
					$.Suggester.instances.splice(i, 1);
					return false;
				}
			});
			return this.$originalInput;
		},    
		/**
		 * Add a tag by a record
		 * @method add
		 * @param {String} value  the tag to add
		 * @param {String} [label=value]  the text to display in the new tag
		 * @param {jQuery} [$item]  Set internally when the record is added by choosing from the suggestion box
		 * @return {jQuery} The jQuery object containing the newly created label or undefined if one was not created
		 *
		 */
		add: function(value, label/*optional*/, $item/*optional*/) {
			var evt, idx, $hidden, $tag, record;
			// with only one argument, look for a matching record
			if (arguments.length == 1) {
				record = this.searchData(value, this.options.valueProperty === this.options.labelProperty ? [this.options.valueProperty] : [this.options.valueProperty,this.options.labelProperty]);
				if (record) {
					value = record[this.options.valueProperty];
					label = record[this.options.labelProperty];
				}
			}
			else if ($item) {
				record = $item.data(&#x27;tag-record&#x27;);
				if (record) {
					value = record[this.options.valueProperty];
					label = record[this.options.labelProperty];
				}
			}
			if (typeof label != &#x27;string&#x27;) {
				label = value;
			}
			if (typeof value != &#x27;string&#x27;) {
				value = label;
			}
			/**
			 * Fired before a tag is added
			 * @event BeforeAdd
			 * @param {String} value  The tag to be added (writeable)
			 * @param {String} label  The value of the tag to be added (writeable)
			 * @param {jQuery} item  The suggestion that was chosen, if any (writeable)
			 * @param {Object} record  The record that was chosen, if any (writeable)
			 * @ifprevented  The tag is not added
			 * @example       
			 
	instance.bind(&#x27;BeforeAdd&#x27;, function(event) {
		if (isSwearWord(evt.value)) {
			event.preventDefault();
			alert(&#x27;Tags cannot be swear words&#x27;);
		}
	});
			 */
			evt = this.publish(&#x27;BeforeAdd&#x27;, {
				value: value,
				label: label,
				item: $item,
				record: record
			});
			if (evt.isDefaultPrevented()) {
				return undefined;
			}
			if (this.options.preventDuplicates) {       
				idx = this.getTagIndex(value);
				if (idx &gt; -1) {
					// duplicate: remove old and continue to add new so that new one will be at the end
					this._spliceTagByIdx(idx);
				}
			}
			// append our hidden input to the widget
			if (this.options.addHiddenInputs) {
				$hidden = $(&#x27;&lt;input type=&quot;hidden&quot; /&gt;&#x27;).attr(&#x27;name&#x27;, this.hiddenName).val(evt.value);
				this.$widget.append($hidden);
			}
			$tag = this.$tagTemplate.clone().data(&#x27;tag-value&#x27;, evt.value).data(&#x27;tag-label&#x27;, evt.label);
			// keep a full record of our chosen tag
			this.tags.push(new $.Suggester.Tag({
				suggester: this,
				index: this.tags.length, 
				$tag: $tag, 
				$hidden: $hidden,
				value: evt.value,
				label: evt.label
			}));
			// set the label&#x27;s display text
			if (this.options.multiselect) {
				$tag.find(&#x27;.sugg-label&#x27;).text(evt.label);
				this.$inputWrapper.before($tag);
			}
			else {
				this.$input.val(evt.value);
			}
			// set the value of the original input
			this.save();      
			/**
			 * Allows you to take action after a tag is added
			 * @event AfterAdd
			 * @param {jQuery} item    The suggestion that was chosen, if any
			 * @param {jQuery} tag     The jQuery element of the tag that was added
			 * @param {jQuery} hidden  The hidden input that was generated
			 * @param {String} value   The value of the tag
			 * @param {String} label   The the label of the tag
			 * @param {String} record  The record that was chosen, if any
			 * @example
			 
	instance.bind(&#x27;AfterAdd&#x27;, function(event) {
		// fade in tag
		event.tag.fadeIn(500);
	});
			 */
			this.publish(&#x27;AfterAdd&#x27;, {
				item: evt.item,
				tag: $tag,
				hidden: $hidden,
				value: evt.value,
				label: evt.label,
				record: evt.record
			});
			return $tag;
		},
		/**
		 * Add a tag with the contents of the input; e.g. when the user has typed something but clicks on another part of the form
		 * Note: this happens on blur when this.options.addOnBlur is true
		 * @method addCurrentBuffer
		 */
		addCurrentBuffer: function() {
			var inputVal = $.trim(this.$input.val());
			if (inputVal !== this.options.placeholder &amp;&amp; inputVal !== &#x27;&#x27;) {
				this.add(inputVal);
				this.$input.val(&#x27;&#x27;);
			}     
		},
		/**
		 * Move the selection up or down in the suggestion box
		 * @method moveSelection
		 * @param {String} [direction=up]  Either &quot;up&quot; or &quot;down&quot;
		 */
		moveSelection: function(direction) {
			// find all the suggestion items
			var $items = this.$suggList.find(&#x27;.sugg-item&#x27;);
			var $nextItem;
			if (this.$currentItem &amp;&amp; this.$currentItem.length) {        
				// if we already selected an item, go next or previous
				$nextItem = (direction == &#x27;down&#x27; ? this.$currentItem.next() : this.$currentItem.prev());
			}
			else {
				// otherwise go to first or last item
				$nextItem = (direction == &#x27;down&#x27; ? $items.first() : $items.last());
			}
			/**
			 * Fire in response to up or down arrow while suggestion list is focused
			 * @event BeforeMove
			 * @param {String} direction  &quot;up&quot; or &quot;down&quot;
			 * @param {jQuery|null} current    jQuery object with the currently selected item or null if there isn&#x27;t one (writeable)
			 * @param {jQuery|null} next       jQuery object with the item that will be selected next (writeable)
			 * @ifprevented  Movement is cancelled
			 * @example

	instance.bind(&#x27;BeforeMove&#x27;, function(event) {
		alert(&#x27;The new selection will be &#x27; + event.next.text());
	});
			
			 */
			var evt = this.publish(&#x27;BeforeMove&#x27;, {
				direction: direction,
				current: this.$currentItem,
				next: $nextItem, 
				cancelable:true
			});
			// allow BeforeMove callbacks to cancel movement
			if (evt.isDefaultPrevented()) {
				return this;
			}
			// deselect current item
			if (evt.current &amp;&amp; evt.current.length) {
				this.deselectItem(evt.current);
			}
			// move to next item
			if (evt.next &amp;&amp; evt.next.length) {
				this.selectItem(evt.next);
			}
			// reset our current items
			this.$currentItem = evt.next;
			/**
			 * Fired after selected suggestion is changed in response to up or down arrow
			 * @event AfterMove
			 * @param {String} direction  &quot;up&quot; or &quot;down&quot;
			 * @param {jQuery|null} last       The previously selected item
			 * @param {jQuery} current    The newly selected item
			 * @example
	
	instance.bind(&#x27;AfterMove&#x27;, function(event) {
		alert(&#x27;The new selection is &#x27; + event.current.text());
	});
			
			 */
			this.publish(&#x27;AfterMove&#x27;, {
				direction: direction,
				last: evt.current,
				current: this.$currentItem
			});
			return this;
		},
		/**
		 * Select a suggestion
		 * @method selectItem
		 * @param {jQuery} $tag
		 * @return {Suggester}
		 */
		selectItem: function($tag) {
			$tag.addClass(&#x27;sugg-selected&#x27;);
			return this;
		},
		/**
		 * Deselect a suggestion
		 * @method deselectItem
		 * @param {jQuery} $tag
		 * @return {Suggester}
		 */   
		deselectItem: function($tag) {
			$tag.removeClass(&#x27;sugg-selected&#x27;);
			return this;
		},
		/**
		 * Deselect all suggestions
		 * @method deselectAllItems
		 * @return {Suggester}
		 */     
		deselectAllItems: function() {
			this.$suggList.find(&#x27;.sugg-item&#x27;).removeClass(&#x27;sugg-selected&#x27;);
			this.$currentItem = null; 
			return this;
		},
		/**
		 * Open suggestion list for the given text
		 * @method suggest
		 * @param {String} text
		 * @return {Suggester}
		 */
		suggest: function(text) {
			this._text = text;
			if (this.options.dataUrl) {
				this.fetchResults(text);
			}
			else {
				this.handleSuggestions(this.getResults(text));
			}
		},
		/**
		 * Add more data records to the autosuggest list. Does not apply when dataUrl is set
		 * @method addData
		 * @params {Object[]} data  More records in the same object format as initially set
		 * @return {Suggester}
		 */
		addData: function(data) {     
			var i, len, record;
			if (data.length &gt; 0 &amp;&amp; typeof data[0] != &#x27;object&#x27;) {
				for (i = 0, len = data.length; i &lt; len; i++) {
					record = {};
					record[this.options.valueProperty] = &#x27;&#x27;+data[i];
					this.data.push(record);
				}
			}
			else {
				this.data = this.data.concat(data);     
			}
			return this;
		},
		/**
		 * Set data records to the autosuggest list. Does not apply when dataUrl is set
		 * @method setData
		 * @params {Object[]} data
		 * @return {Suggester}
		 */   
		setData: function(data) {
			this.data = [];
			this.addData(data);
			return this;
		},
		/**
		 * Get all the records in the autosuggest list. Does not apply when dataUrl is set
		 * @method getData
		 * @return {Object[]}
		 */   
		getData: function() {
			return this.data;
		},
		/**
		 * Set the direction of the suggestion menu, to fly upwards or downwards
		 * @method setFlyDirection
		 * @param {String} direction  either &quot;up&quot; or &quot;down&quot;
		 * @return {Suggester}
		 */
		setFlyDirection: function(direction) {
			// if the suggestion list should fly upwards instead of downwards, put the suggestion list before the input container in the dom tree
			if (direction == &#x27;up&#x27;) {
				this.$suggListWrapper.insertBefore(this.$box);
				this.$widget.removeClass(&#x27;sugg-fly-down&#x27;).addClass(&#x27;sugg-fly-up&#x27;);
			}
			else if (direction == &#x27;down&#x27;) {
				this.$suggListWrapper.insertAfter(this.$box);
				this.$widget.addClass(&#x27;sugg-fly-down&#x27;).removeClass(&#x27;sugg-fly-up&#x27;);
			}
			// TODO: support auto by checking window scroll position
			return this;
		},
		/**
		 * Focus on a previously added tag
		 * @method focusTag
		 * @params {jQuery} $tag  The .sugg-tag element to focus
		 * @return {Suggester}
		 */
		focusTag: function($tag) {
			this.unfocusTag();
			this.$focusedTag = $tag.addClass(&#x27;sugg-focused&#x27;);
			// remove tag if user presses delete or backspace
			$document.keydown(this.removeFocusedTag).click(this.unfocusTag);
			return this;
		},
		/**
		 * Unfocus the previously focussed tag
		 * @method unfocusTag
		 * @return {Suggester}
		 */
		unfocusTag: function() {
			$document.unbind(&#x27;keydown&#x27;, this.removeFocusedTag).unbind(&#x27;click&#x27;, this.unfocusTag);
			if (this.$focusedTag) {
				this.$focusedTag.removeClass(&#x27;sugg-focused&#x27;);
			}
			this.$focusedTag = null;
			return this;
		},
		/**
		 * Remove the focused tag
		 * @method removeFocusedTag
		 * @param {jQuery.Event} evt (optional)  Used to check if $document keypress is backspace or delete
		 * @return {Suggester}
		 */
		removeFocusedTag: function(evt) {
			if (evt &amp;&amp; evt.which &amp;&amp; (evt.which == 8 || evt.which == 46)) {
				// delete or backspace key                
				if (this.$focusedTag) {
					this.remove(this.$focusedTag);
				}
				evt.preventDefault();
			} 
			this.unfocusTag();
			return this;
		},
		/**
		 * Remove a tag given its text or jQuery element or HTML element
		 * @method remove
		 * @param {String|jQuery|HTMLElement} $tag  the tag to remove
		 * @return {Suggester}
		 * @chainable
		 */
		remove: function($tag) {
			var evt, value, label, removed;
			if (typeof $tag.nodeType == &#x27;number&#x27; &amp;&amp; typeof $tag.style == &#x27;object&#x27;) {
				// DOM Element
				$tag = $($tag);
			}
			if ($tag instanceof $) {
				// jQuery object
				value = $tag.data(&#x27;tag-value&#x27;);
			}
			else {
				// String
				value = $tag;
				$tag = false;
				for (var i = 0, len = this.tags.length; i &lt; len; i++) {
					if (value == this.tags[i].getValue() || value == this.tags[i].getLabel()) {
						$tag = this.tags[i].getElement();
						break;
					}
				}
				if (!$tag) {
					return this;
				}
			}
			label = $tag.data(&#x27;tag-label&#x27;);
			/**
			 * Fired before a tag is removed
			 * @event BeforeRemove
			 * @param {jQuery} tag  The tag to be removed
			 * @param {String} value  The value of the tag to be removed (writeable)
			 * @param {String} label  The label of the tag to be removed
			 * @ifprevented The tag will not be removed
			 * @example
			 
	instance.bind(&#x27;BeforeRemove&#x27;, function(event) {
		if (!confirm(&#x27;Are you sure you want to remove the tag &quot;&#x27; + event.label + &#x27;&quot;?&#x27;)) {
			event.preventDefault();
		}
	});
			 
			 */
			evt = this.publish(&#x27;BeforeRemove&#x27;, {
				tag: $tag,
				value: value,
				label: label,
				cancelable: true
			});
			if (evt.isDefaultPrevented()) {
				return this;
			}     
			removed = this._spliceTag(evt.value);
			// save to our hidden input
			this.save();
			/**
			 * Fired after a tag is removed
			 * @event AfterRemove
			 * @param {jQuery} tag  The tag element that was removed
			 * @param {String} value  The value of the tag that was removed
			 * @param {String} label  The label of the tag that was removed
			 * @param {Suggester.Tag}  The tag object that was removed
			 */			
			this.publish(&#x27;AfterRemove&#x27;, {
				tag: $tag,
				value: evt.value,
				label: label,
				removed: removed
			});
			return this;
		},
		/**
		 * Find a suggestion record by text. Only applies when this.options.data is set.
		 * @method findRecord
		 * @param {String} text  The text to search for
		 * @return {Object|false}  The matched record object or false if nothing matched.
		 */   
		findRecord: function(text) {
			return this.searchData(text, this.options.searchProperties); 
		}, 
		/**
		 * Search through this.data to find a record with a value or label equal to the given value
		 * @method searchData
		 * @param {String} value  The value or label to find
		 * @param {Array} props  An array of strings of property names to search
		 * @return {Object|Boolean}  Returns the record if found, false if not found
		 */
		searchData: function(value, props) {
			var i, len, j, numProps, prop;
			var data = this.getData();
			len = data.length;
			numProps = props.length;
			if (len === 0 || numProps === 0) {
				return false;
			}
			// ensure value is a string
			value = &#x27;&#x27; + value;
			// optimize for case when value there is only one property
			if (numProps == 1) {
				prop = props[0];
				// run through each record
				if (this.options.caseSensitive) {
					for (i = 0; i &lt; len; i++) {
						if (data[i][prop] === value) {
							return data[i];
						}
					}
				} else {
					value = value.toLowerCase();
					for (i = 0; i &lt; len; i++) {
						// check the value lowercase property
						if (typeof data[i][prop] == &#x27;string&#x27; &amp;&amp; data[i][prop].toLowerCase() === value) {
							return data[i];
						}
					}
				}
			}
			else {
				// run through each record and each property			
				if (this.options.caseSensitive) {
					for (i = 0; i &lt; len; i++) {
						for (j = 0; j &lt; numProps; j++) {						
							if (data[i][ props[j] ] === value) {
								return data[i];
							}
						}
					}
				} else {
					value = value.toLowerCase();
					for (i = 0; i &lt; len; i++) {
						for (j = 0; j &lt; numProps; j++) {						
							if (typeof data[i][ props[j] ] == &#x27;string&#x27; &amp;&amp; data[i][ props[j] ].toLowerCase() === value) {
								return data[i];
							}
						}						
					}
				}				
			}
			return false;
		},
		/**
		 * Initiate suggestion process if the input text is &gt;= this.options.minChars, otherwise show prompt
		 * @method suggestIfNeeded
		 * @return {Suggester}
		 * @chainable
		 */
		suggestIfNeeded: function() {
			var text = this.$input.val();
			if (text.length &gt;= this.options.minChars) {       
				this.suggest(text);
			}
			else if (this.options.prompt) {
				this.showPrompt();
			}
			else {
				this.closeSuggestBox();
			}     
			return this;
		},
		/**
		 * Show the prompt text to give a hint to users. Only called when there are no items and this.options.prompt is truthy
		 * @method showPrompt
		 * @return {Suggester}
		 */
		showPrompt: function() {
			if (!this.$prompt) {
				return this;
			}
			this.$suggList.html(&#x27;&#x27;).append(this.$prompt);
			this.openSuggestBox();
			this.$widget.addClass(&#x27;sugg-prompt-shown&#x27;);
			return this;
		},
		/**
		 * Show text indicating there are no suggestions - defined in this.options.emptyText
		 * @method showEmptyText
		 * @return {Suggester}
		 * @chainable
		 */   
		showEmptyText: function() {
			this.$suggList.html(&#x27;&#x27;);
			if (!!this.options.emptyText) {
				this.$empty.html(this.options.emptyText).appendTo(this.$suggList);
				this.openSuggestBox();
				this.$widget.addClass(&#x27;sugg-empty-shown&#x27;);				
			}
			else {
				this.closeSuggestBox();				
			}
			return this;
		},
		/**
		 * Fetch suggestions from an ajax URL
		 * @method fetchResults
		 * @param {String} text  The text to search for
		 * @return {jqXHR}  The jQuery XHR transport that is fetching the data
		 */
		fetchResults: function(text) {
			this._searchTerm = text;
			var settings = {
				context: this,
				url: this.options.dataUrl.replace(&#x27;%s&#x27;, text)
			};
			if (this.options.dataType.toLowerCase() == &#x27;json&#x27;) {
				settings.dataType = &#x27;json&#x27;;
			}
			else if (this.options.dataType.toLowerCase() == &#x27;jsonp&#x27;) {
				settings.dataType = &#x27;jsonp&#x27;;
				// jQuery replaces second question mark with callback name
				settings.url = settings.url.replace(&#x27;%s&#x27;, &#x27;?&#x27;);
			}
			else {
				throw new Error(&#x27;jQuery.Suggester#fetchResults: options.dataType must be &quot;json&quot; or &quot;jsonp&quot;.&#x27;);
			}
			/**
			 * Edit settings before ajax request is sent
			 * @event BeforeAjax
			 * @param {Object} settings  Settings sent to $.ajax()
			 * @param {String} term  The term for which we will search
			 * @ifcancelled  Ajax is not run and this._afterFetch is run
			 * @example
			 
	instance.bind(&#x27;BeforeAjax&#x27;, function(event) {
		event.settings.timeout = 5000;
		startSpinner(event.term);
	});			 
			 
			 */
			var evt = this.publish(&#x27;BeforeAjax&#x27;, {
				settings: settings,
				term: text,
				cancelable: true
			});
			if (evt.isDefaultPrevented()) {
				this._afterFetch(evt.records || []);
				return false;
			}
			evt.settings.beforeSend = this._beforeFetch;
			var jqXHR = $.ajax(evt.settings).done(this._afterFetch);
			/**
			 * Access the jqXHR after initiating the ajax call but before it returns
			 * @event AfterAjax
			 * @param {Object} settings  Settings sent to $.ajax()
			 * @param {String} term  The term which was searched
			 * @param {jqXHR} jqXHR  The jquery XMLHttpRequest object
			 * @example
			 
	instance.bind(&#x27;AfterAjax&#x27;, function(event) {
		event.jqXHR.done(stopSpinner);	
	});
			 
			 */
			this.publish(&#x27;AfterAjax&#x27;, {
				settings: evt.settings,
				term: evt.term,
				jqXHR: jqXHR
			});
			return jqXHR;
		},
		/**
		 * Cancel the XHR. Used when user starts typing again before XHR completes
		 * @method abortFetch
		 * @return {Suggester}
		 * @chainable
		 */
		abortFetch: function() {
			if (this._jqXHR) {
				this._jqXHR.abort();
			}
			return this;
		},
		/**
		 * Take the given records and build and display suggestion box. Usually only called internally.
		 * @method handleSuggestions
		 * @param {Array} records  The result records to use to build the suggestion list
		 * @return {Suggester}
		 * @chainable
		 */
		handleSuggestions: function(records) {
			if (!records || records.length === 0) {
				this.showEmptyText();
				return this;
			}
			var $suggestion;
			// clear out the suggestion list including all nodes and data
			this.$suggList.empty();
			for (var i = 0, len = records.length; i &lt; len; i++) {
				$suggestion = $(this._formatSuggestion(records[i], this._text));
				$suggestion.data(&#x27;tag-record&#x27;, records[i]);
				this.$suggList.append($suggestion);
			}
			/**
			 * Modify suggestion box behavior before it opens
			 * @event BeforeSuggest
			 * @param {String} text  The text that was searched for
			 * @ifprevented  The suggestion list is built but not displayed
			 * @example

	instance.bind(&#x27;BeforeSuggest&#x27;, function(event) {
		if (evt.text == &#x27;dont suggest&#x27;) {
			event.preventDefault(); // suggest box will not open
		}
	});

			*/			
			var evt = this.publish(&#x27;BeforeSuggest&#x27;, {
				text: this._text,
				cancelable: true
			});
			if (evt.isDefaultPrevented()) {
				return this;
			}
			this.openSuggestBox();
			/**
			 * Fires after displaying suggestions
			 * @event AfterSuggest
			 */			
			this.publish(&#x27;AfterSuggest&#x27;);
			return this;
		},
		/**
		 * Return true if suggestion box is open
		 * @method isSuggestBoxOpen
		 * @return {Boolean}
		 */
		isSuggestBoxOpen: function() {
			return this.$suggList.css(&#x27;display&#x27;) != &#x27;none&#x27;;
		},
		/**
		 * Manually open the suggestion box in whatever state it is. Usually only called internally.
		 * @method openSuggestBox
		 * @return {Suggester}
		 * @chainable
		 */
		openSuggestBox: function() {      
			var evt, bodyOffset, width, height, pos, top, left, sugg = this;
			if (this.options.suggListPosition == &#x27;absolute&#x27;) {
				bodyOffset = $(document.body).offset();
				pos = this.$box.position();
				if (this.options.fly == &#x27;up&#x27;) {
					// we have to show but set visibility to hidden so that we can get the outerHeight
					this.$suggList.css(&#x27;visibility&#x27;,&#x27;hidden&#x27;).show();
					top = pos.top - bodyOffset.top - this.$box.outerHeight() + this.$box.height() - this.$suggList.outerHeight();
					this.$suggList.hide().css(&#x27;visibility&#x27;,&#x27;visible&#x27;);
				}
				else {
					top = pos.top - bodyOffset.top + this.$box.outerHeight();
				}
				left = pos.left - bodyOffset.left;
				width = this.$box.outerWidth();
				this.$suggList.css({
					top: top+&#x27;px&#x27;,
					left: left+&#x27;px&#x27;,
					width: width
				});   
			}
			/**
			 * Fires before suggestion box is displayed
			 * @event BeforeOpen
			 * @ifprevented  Box is not displayed
			 */			
			evt = this.publish(&#x27;BeforeOpen&#x27;, {
				cancelable: true
			});     
			if (evt.isDefaultPrevented()) {
				return this;
			}
			this.$widget
			.addClass(&#x27;sugg-list-open&#x27;)
			.removeClass(&#x27;sugg-prompt-shown&#x27;)
			.removeClass(&#x27;sugg-empty-shown&#x27;);
			setTimeout(function() {       
				$document.bind(&#x27;click&#x27;, sugg._closeOnOutsideClick);
			}, 0);
			this.$suggList.show();
			/**
			 * Fires after suggestion box is displayed
			 * @event AfterOpen
			 */			
			this.publish(&#x27;AfterOpen&#x27;);
			return this;      
		},
		/**
		 * Hide the suggestion box
		 * @method closeSuggestBox
		 * @return {Suggester}
		 * @chainable
		 */
		closeSuggestBox: function() {
			$document.unbind(&#x27;click&#x27;, this._closeOnOutsideClick);
			/**
			 * Fired before suggestion box is hidden
			 * @event BeforeClose
			 * @ifprevented  Suggestion box will stay open
			 */
			var evt = this.publish(&#x27;BeforeClose&#x27;, {
				cancelable:true
			});
			if (!evt.isDefaultPrevented()) {
				this.$suggList.hide();
				this.$widget.removeClass(&#x27;sugg-list-open&#x27;);
			}
			/**
			 * Fired after suggestion box is hidden
			 * @event AfterClose
			 */			
			this.publish(&#x27;AfterClose&#x27;);
			return this;
		},
		/**
		 * Focus cursor on text input box
		 * @method focus
		 * @return {Suggester}
		 * @chainable
		 */
		focus: function() {
			// use the dom method to focus
			this.$input[0].focus();
			return this;
		},
		/**
		 * Get suggestion result records given some text (local data)
		 * @method getResults
		 * @param {String} text  Gather suggestions based on this text
		 * @return {Array}  Array of Objects of matching records 
		 */
		getResults: function(text) {
			text = &#x27;&#x27;+text;
			/**
			 * Called before the search for results
			 * @event BeforeFilter
			 * @param {String} text  The text to search for
			 * @example

	instance.bind(&#x27;BeforeFilter&#x27;, function(event) {
		// remove all special characters from input text
		event.text = event.text.replace(/[^\w ]/g, &#x27;&#x27;);
	});

			 */
			var evt = this.publish(&#x27;BeforeFilter&#x27;, {
				text: text
			});     
			if (!this.options.caseSensitive) {
				var casedText = evt.text.toLowerCase();
			}     
			var sugg = this;
			var results = [];
			$.each(this.getData(), function(i, record) {        
				if (sugg.options.omitAlreadyChosenItems &amp;&amp; sugg.getTagIndex(record[sugg.options.valueProperty]) &gt; -1) {
					// tag already exists so don&#x27;t suggest it
					// skip loop
					return;
				}
				$.each(sugg.options.searchProperties, function() {          
					var value = &#x27;&#x27; + (record[this] || &#x27;&#x27;);
					if (!sugg.options.caseSensitive) {
						value = value.toLowerCase();
					}         
					if (
						(sugg.options.matchAt == &#x27;anywhere&#x27; &amp;&amp; value.indexOf(casedText) &gt; -1) ||
						(value.indexOf(casedText) == sugg.options.matchAt) ||
						(sugg.options.matchAt == &#x27;end&#x27; &amp;&amp; value.indexOf(casedText) == value.length - casedText-length) 
						) {
						results.push(record);
						return false;
					}
				});
				if (sugg.options.maxSuggestions &gt; 0 &amp;&amp; results.length &gt;= sugg.options.maxSuggestions) {
					// exit the loop
					return false;
				}
			});
			/**
			 * Called after the search for results
			 * @event AfterFilter
			 * @param {String} text  The that was searched for
			 * @param {Array} results  The array of records that matched (writeable)
			 * @example

	instance.bind(&#x27;AfterFilter&#x27;, function(event) {
		// add a result onto the beginning
		event.results.unshift({value:&#x27;Search the web for &quot;&#x27; + event.text &#x27;&quot;&#x27;);
	});

			 */			
			evt = this.publish(&#x27;AfterFilter&#x27;, {
				text: evt.text,
				results: results
			});
			return evt.results;
		},
		/**
		 * Clear all the chosen tags
		 * @method clear
		 * @return {Suggester}
		 * @chainable
		 */
		clear: function() {
			$.each(this.tags, function() {
				this.getHidden().remove();
				this.getElement().remove(); 
			}); 
			this.tags = [];
			this.save();
			return this;
		},
		/**
		 * Get a collection of all the chosen tag objects
		 * @method getTags
		 * @return {Array}
		 */
		getTags: function() {
			return Array.prototype.slice.call(this.tags);
		},
		/**
		 * Iterate through each of the chosen tag objects
		 * @method eachTag
		 * @param {Function} iterator  The iterator function - function(i, tag) {}
		 * @return {Suggester}
		 * @chainable
		 */
		eachTag: function(iterator) {
			$.each(this.getTags(), iterator);
			return this;
		},
		/**
		 * Return a URL query string representing the hidden values of the input
		 * @method serialize
		 * @return {String}
		 */
		serialize: function() {
			var query = [];
			for (var i = 0, len = this.tags.length; i &lt; len; i++) {
				query.push( encodeURIComponent(this.tags[i].getHidden().name) + &#x27;=&#x27; + encodeURIComponent(this.tags[i].getHidden().value) );
			}
			return query.join(&#x27;&amp;&#x27;);
		},
		/**
		 * Pluck all the tag values from the chosen tags
		 * @method getValues
		 * @return {Array}
		 */
		getValues: function() {
			var values = [];
			for (var i = 0, len = this.tags.length; i &lt; len; i++) {
				values.push( this.tags[i].getValue() );
			}
			return values;
		},
		/**
		 * Get the current value as a comma-delimited string
		 * @method getValue
		 * @return {String}
		 */
		getValue: function() {
			return this.getValues().join(&#x27;,&#x27;);
		},
		/**
		 * Set the widget&#x27;s CSS theme - Adds a class &quot;sugg-theme-%name%&quot; to the widget
		 * @method setTheme
		 * @param {String} themeName  The name of the theme to use
		 * @return {Suggester}
		 * @chainable
		 */
		setTheme: function(themeName) {
			if (this._theme) {
				this.$widget.removeClass(&#x27;sugg-theme-&#x27; + this._theme);
			}
			this._theme = themeName;
			this.$widget.addClass(&#x27;sugg-theme-&#x27; + this._theme);
			return this;
		},
		/**
		 * Publish the given event name and send the given data
		 * @method publish
		 * @param {String} type  The name of the event to publish
		 * @param {Object} data  Additional data to attach to the event object
		 * @return {jQuery.Event}  The event object which behaves much like a DOM event object
		 */
		publish: function(type, data) {
			var evt = $.Event(type);
			evt.target = this;
			if (data) {
				$.extend(evt, data);
			}
			this.trigger(evt);
			return evt;
		},
		/**
		 * Get this instance. Useful for jQuery-style usage:  var instance = $(&#x27;input&#x27;).suggester(options).suggester(&#x27;getInstance&#x27;)
		 * @method getInstance
		 * @return {Suggester}
		 */
		getInstance: function() {
			return this;
		},    
		/**
		 * Set options and interpret options
		 * @method _processOptions
		 * @params {Object} options  Settings passed to constructor
		 */
		_processOptions: function(options) {
			this.options = $.extend({}, $.Suggester.defaultOptions, options);
			// interpret some overloaded options      
			if (this.options.matchAt == &#x27;start&#x27; || this.options.matchAt == &#x27;beginning&#x27;) {
				this.options.matchAt = 0;
			}
		},    
		/**
		 * Render the widget and get handles to key elements
		 * @method _render
		 */
		_render: function() {
			// The full widget
			this.$widget = $(this.options.template);
			// BeforeRender callbacks now have the ability to modify this.$widget or any of its child elements
			/**
			 * Modify this.$widget or any of its child elements before it is manipulated or appended. Can be used to modify this.options.template with DOM methods
			 * @event BeforeRender
			 * @param {jQuery} widget  A reference to this.$widget
			 * @example
			 
	instance.bind(&#x27;BeforeRender&#x27;, function(event) {
		event.widget.find(&#x27;.sugg-remove&#x27;).text(&#x27;&#x27;).appendChild(myRemoveImage);
	});
			 
			 */
			this.publish(&#x27;BeforeRender&#x27;, {
				widget: this.$widget
			});
			// the container that tags and the input box are in
			this.$box = this.$widget.find(&#x27;.sugg-box&#x27;);
			// the template for tags
			this.$tagTemplate = this.$box.find(&#x27;.sugg-tag&#x27;).remove();
			// the text input used to type tags
			this.$input = this.$box.find(&#x27;.sugg-input&#x27;);
			if (this.options.placeholder) {
				this.$widget.addClass(&#x27;sugg-placeholder-on&#x27;);
				this.$input.val(this.options.placeholder);
			}
			// the wrapper for that text input
			this.$inputWrapper = this.$box.find(&#x27;.sugg-input-wrapper&#x27;);
			// the list element that contains all suggestions
			this.$suggListWrapper = this.$widget.find(&#x27;.sugg-list-wrapper&#x27;);
			this.$suggList = this.$widget.find(&#x27;.sugg-list&#x27;);
			if (this.options.suggListPosition == &#x27;absolute&#x27;) {
				this.$suggList.appendTo(document.body);
				document.body.style.position = &#x27;relative&#x27;;
				this.$suggList.css(&#x27;position&#x27;,&#x27;absolute&#x27;);
			}     
			// nodes to use for no suggestions and prompt
			this.$empty = this.$suggList.find(&#x27;.sugg-empty&#x27;).html(this.options.emptyText).remove();
			this.$prompt = this.$suggList.find(&#x27;.sugg-prompt&#x27;).html(this.options.prompt || &#x27;&#x27;).remove();
			// the template html to use for suggestions
			this.listItemTemplate = this.options.listItemTemplate || this.$suggList.html();     
			// we got that html, now empty it out
			this.$suggList.html(&#x27;&#x27;);
			// make the list fly up or down
			this.setFlyDirection(this.options.fly);
			// actually insert the widget
			this.$widget.insertBefore(this.$originalInput.hide());
			// populate tags based on starting value of original input
			this._handleStartValue();
			if (this.options.minChars === 0) {
				// when minChars is 0, it acts like a regular drop down box
				this.options.inputSize = &#x27;&#x27;;
				// set input width to remaining room
				// TODO: handle border-box and padding-box box sizing
				// TODO: consider position absolute and width 100% height 100%
				this.$input.width(
					this.$box.width() 
					- parseFloat(this.$inputWrapper.css(&#x27;paddingLeft&#x27;))
					- parseFloat(this.$inputWrapper.css(&#x27;paddingRight&#x27;))
					- parseFloat(this.$inputWrapper.css(&#x27;marginLeft&#x27;))
					- parseFloat(this.$inputWrapper.css(&#x27;marginRight&#x27;))
					- parseFloat(this.$inputWrapper.css(&#x27;borderLeftWidth&#x27;))
					- parseFloat(this.$inputWrapper.css(&#x27;borderRightWidth&#x27;))
					- parseFloat(this.$input.css(&#x27;paddingLeft&#x27;))
					- parseFloat(this.$input.css(&#x27;paddingRight&#x27;))
					- parseFloat(this.$input.css(&#x27;marginLeft&#x27;))
					- parseFloat(this.$input.css(&#x27;marginRight&#x27;))
					- parseFloat(this.$input.css(&#x27;borderLeftWidth&#x27;))
					- parseFloat(this.$input.css(&#x27;borderRightWidth&#x27;))
					);
			}
			this._updateInputSize();
			if (this.options.theme) {
				this.setTheme(this.options.theme);
			}
			/**
			 * Do something after the widget is completely rendered
			 * @event AfterRender
			 * @param {jQuery} widget  A reference to this.$widget
			 * @example
			 
	instance.bind(&#x27;AfterRender&#x27;, function(event) {
		heyItsAllRendered();
	});
			 
			 */
			this.publish(&#x27;AfterRender&#x27;, {
				widget: this.$widget
			});
		},
		/**
		 * Look at the initial element&#x27;s start value and populate tags as appropriate
		 * @method _handleStartValue
		 */
		_handleStartValue: function() {
			// get a list of tags to insert now based on the current value of the original input
			// replaces escaped commas with \u0001 such that tag labels can have commas
			// if JavaScript RegExp supported lookbehinds we wouldn&#x27;t need this \u0001 deal
			var startVal = this.$originalInput.val();
			if (startVal) {
				this.$widget.removeClass(&#x27;sugg-placeholder-on&#x27;);
				var existingTags = startVal.replace(/\\,/g, &#x27;\u0001,&#x27;).split(/,/g);
				this.$originalInput.val(&#x27;&#x27;);
				var sugg = this;
				$.each(existingTags, function() {
					// add each tag by its label; this.$originalInput will get repopulated automatically
					sugg.add($.trim(this.replace(/\u0001/g, &#x27;&#x27;)));
				});
			}     
		},
		/**
		 * Attach event handlers
		 * @method _setupListeners
		 */
		_setupListeners: function() {
			// proxy some methods to always be bound to our instance
			this.unfocusTag = $.proxy(this, &#x27;unfocusTag&#x27;);
			this.removeFocusedTag = $.proxy(this, &#x27;removeFocusedTag&#x27;);
			this.suggestIfNeeded = $.proxy(this, &#x27;suggestIfNeeded&#x27;);
			this._closeOnOutsideClick = $.proxy(this, &#x27;_closeOnOutsideClick&#x27;);
			// clear default text if focused on input
			this.$input.focus($.proxy(this, &#x27;_onInputFocus&#x27;));
			this.$input.blur($.proxy(this, &#x27;_onInputBlur&#x27;));
			// remove tags when &#x60;X&#x60; is clicked
			this.$box.delegate(&#x27;.sugg-remove&#x27;, &#x27;click&#x27;, $.proxy(this, &#x27;_onTagRemoveClick&#x27;));
			// focus tags when clicked (for pre-deletion)
			this.$box.delegate(&#x27;.sugg-tag&#x27;, &#x27;click&#x27;, $.proxy(this, &#x27;_onTagClick&#x27;));
			// highlight suggestion on mouseover
			this.$suggList.mouseover($.proxy(this, &#x27;_onListMouseover&#x27;));
			// add a tag when suggestion is clicked
			this.$suggList.click($.proxy(this, &#x27;_onListClick&#x27;));
			// focus to text input field when a click comes outside of any tags
			this.$box.click($.proxy(this, &#x27;_onBoxClick&#x27;));
			// handle various actions associated with keypresses
			$.Suggester.quickBind(this.$input.get(0), &#x27;keydown&#x27;, $.proxy(this, &#x27;_onKeydown&#x27;));
			// handle paste into tag field
			this.$input.bind(&#x27;cut delete&#x27;, $.proxy(this, &#x27;_onCutDelete&#x27;));
			this.$input.bind(&#x27;paste&#x27;, $.proxy(this, &#x27;_onPaste&#x27;));
			// auto add tags on submit
			this.$form.submit($.proxy(this, &#x27;_onSubmit&#x27;));
		},
		/**
		 * Event handler for when this.$input is focused
		 * @method _onInputFocus
		 * @param {jQuery.Event} evt  The focus event
		 */
		_onInputFocus: function(evt) {
			this.$widget.addClass(&#x27;sugg-active&#x27;);
			this.$widget.removeClass(&#x27;sugg-placeholder-on&#x27;);
			var currVal = this.$input.val();
			this.unfocusTag();
			if (this.options.minChars === 0 &amp;&amp; this.data.length &gt; 0) {
				this.handleSuggestions(this.options.maxSuggestions &gt; 0 ? this.data.slice(0, this.options.maxSuggestions) : this.data);
			}     
			else if (currVal === this.options.placeholder) {
				this.$input.val(&#x27;&#x27;);
				this._updateInputSize();
			}
			else if (currVal === &#x27;&#x27; &amp; !!this.options.prompt) {
				this.showPrompt();
			}
		},
		/**
		 * Event handler for when this.$input is blurred
		 * @method _onInputBlur
		 * @param {jQuery.Event} evt  blur event
		 */
		_onInputBlur: function(evt) {
			var inputVal = $.trim(this.$input.val());
			if (this.options.placeholder &amp;&amp; inputVal === this.options.placeholder) {
				this.$widget.addClass(&#x27;sugg-placeholder-on&#x27;);
			}
			else if (inputVal !== &#x27;&#x27; &amp;&amp; this.options.addOnBlur) {
				var sugg = this;
				// the timeout will be cleared if the user has chosen a suggestion
				this._onInputBlurTimeout = setTimeout(function() {		
					sugg.add(inputVal);
					sugg.$input.val(&#x27;&#x27;);
				}, 500);
			}
			this.$widget.removeClass(&#x27;sugg-active&#x27;);      
		},
		/**
		 * Event handler for when .sugg-remove is clicked
		 * @method _onTagRemoveClick
		 * @param {jQuery.Event} evt  The click event
		 */   
		_onTagRemoveClick: function(evt) {
			this.unfocusTag();
			evt.preventDefault();
			evt.stopImmediatePropagation();
			var $tag = $(evt.target).parents(&#x27;.sugg-tag&#x27;);
			this.remove($tag);
		},
		/**
		 * Event handler for when .sugg-tag is clicked
		 * @method _onTagClick
		 * @param {jQuery.Event} evt  The click event
		 */     
		_onTagClick: function(evt) {
			var $target = $(evt.target);
			if (!$target.hasClass(&#x27;sugg-tag&#x27;)) {
				$target = $target.parents(&#x27;.sugg-tag&#x27;);
			}
			// we have to stop propagation to $box click and to $document
			evt.stopImmediatePropagation();
			this.focusTag($target); 
		},
		/**
		 * Event handler for when autosuggest list is moused over
		 * @method _onListMouseover
		 * @param {jQuery.Event} evt  The mouseover event
		 */     
		_onListMouseover: function(evt) { 
			var $target = $(evt.target);
			if ($target.hasClass(&#x27;sugg-list&#x27;)) {
				return;
			}
			if (!$target.hasClass(&#x27;sugg-item&#x27;)) {
				$target = $target.parents(&#x27;.sugg-item&#x27;);
			}
			if (!$target.hasClass(&#x27;sugg-item&#x27;)) {
				return;
			}
			this.deselectAllItems();
			this.selectItem($target);
			this.$currentItem = $target;
		},
		/**
		 * Event handler for when autosuggest list is clicked
		 * @method _onListClick
		 * @param {jQuery.Event} evt  The click event
		 */     
		_onListClick: function(evt) {
			clearTimeout(this._onInputBlurTimeout);
			// effectively delegate click to .sugg-item
			var $target = $(evt.target);
			if ($target.hasClass(&#x27;sugg-list&#x27;)) {
				return;
			}
			if (!$target.hasClass(&#x27;sugg-item&#x27;)) {
				$target = $target.parents(&#x27;.sugg-item&#x27;);
			}
			if (!$target.hasClass(&#x27;sugg-item&#x27;)) {
				return;
			}
			var record = $target.data(&#x27;tag-record&#x27;);
			this.add(record[this.options.valueProperty], record[this.options.labelProperty], $target);
			this.closeSuggestBox();
			if (this.options.multiselect) {
				this.$input.val(&#x27;&#x27;);
				this._updateInputSize();
				this.focus();
			}
		},
		/**
		 * Event handler for when this.$box is clicked
		 * @method _onBoxClick
		 * @param {jQuery.Event} evt  The click event
		 */     
		_onBoxClick: function(evt) {
			if (evt.target == this.$box[0]) {
				this.unfocusTag();
				this.focus();
			}
		},
		/**
		 * Handle keypresses while in tag input field
		 * @method _onKeydown
		 * @param {Event} evt  The keydown event (a raw browser event, not jQuery.Event)
		 */
		_onKeydown: function(evt) {
			/**
			 * Access the keydown event before Suggester processes it
			 * @event BeforeHandleKey
			 * @param {Event} keydown  The keydown event (a raw browser event, not jQuery.Event)
			 * @ifprevented  Key is not handled by Suggester. You may want to call event.keydown.preventDefault();
			 */
			var pubevent = this.publish(&#x27;BeforeHandleKey&#x27;, {
				keydown: evt,
				cancelable: true
			});
			if (pubevent.isDefaultPrevented()) {
				return;
			}
			var hasMetaKey = (evt.metaKey || evt.shiftKey || evt.altKey);
			if (hasMetaKey) {
				this._key_other(evt);
			}
			else {
				if (evt.which == 38) { // Up
					this._key_UP(evt);
				}
				else if (evt.which == 40) { // Down
					this._key_DOWN(evt);
				}
				else if (evt.which == 8) { // Backspace
					this._key_BACKSPACE(evt);
				}
				else if (
					(this.options.addOnTab &amp;&amp; evt.which == 9) || 
					(this.options.addOnComma &amp;&amp; evt.which == 188) ||
					(this.options.addOnSemicolon &amp;&amp; evt.which == 59)
					) {
					this._key_TAB_COMMA(evt);
				}
				else if (evt.which == 27) { // Esc
					this._key_ESC(evt);
				}
				else if (evt.which == 13) { // Enter
					this._key_ENTER(evt);
				}
				else { // other keys
					this._key_other(evt);
				}
			}
			this._updateInputSize();
			/**
			 * Access the keydown event after Suggester processes it
			 * @event AfterHandleKey
			 * @param {Event} keydown  The keydown event (a raw browser event, not jQuery.Event)
			 */			
			this.publish(&#x27;AfterHandleKey&#x27;, {
				keydown: evt
			});
		},
		/**
		 * Handle cut and delete on this.$input
		 * @method _onCutDelete
		 * @param {jQuery.Event} evt  The cut, paste, or delete event
		 */
		_onCutDelete: function(evt) {
			// when cut or delete fires, input hasn&#x27;t yet been updated so run on timeout
			setTimeout($.proxy(this._updateInputSize, this), 0);    
		},
		/**
		 * Handle paste on this.$input. Look for places to split pasted value
		 * For example pasting &quot;a, b, c&quot; will immediately add 3 tags (when this.options.addOnComma is true)
		 * It attempts to split on tab, then if there are no tabs then semicolons, then if there are no semicolons, commas
		 * @method _onPaste
		 * @param {jQuery.Event} evt  the paste event
		 */		
		_onPaste: function(evt) {
			var value, parts = [], tags = [], part, i, len;
			// get pasted value (see http://stackoverflow.com/questions/6035071/intercept-paste-event-in-javascript)
			try {
				// modern browsers
				value = evt.originalEvent.clipboardData.getData(&#x27;text/plain&#x27;);
			}
			catch (e) {
				// Lesser IE
				value = window.clipboardData.getData(&#x27;Text&#x27;);
			}
			evt.preventDefault();
			if (this.options.addOnTab) {
				parts = value.split(&#x27;\t&#x27;);
			}
			if (parts.length &lt; 2 &amp;&amp; this.options.addOnSemicolon) {
				parts = value.split(&#x27;;&#x27;);
			}
			if (parts.length &lt; 2 &amp;&amp; this.options.addOnComma) {
				parts = value.split(&#x27;,&#x27;);
			}
			if (parts.length &gt; 0) {
				for (i = 0, len = parts.length; i &lt; len; i++) {				
					part = $.trim(parts[i]);
					if (part !== &#x27;&#x27;) {
						tags.push(part);
					}
				}
			}
			/**
			 * Respond before values are pasted
			 * @event BeforePaste
			 * @param {jQuery.Event} event  The paste event
			 * @param {String} value  The raw value that was pasted
			 * @param {Array} tags  The array of tags to be added (if the value was successfully split on tab, semicolon, or comma). If changed, the added tags will change.
			 * @ifprevented  tags are not added and paste is cancelled
			 * @example      

	instance.bind(&#x27;BeforePaste&#x27;, function(event) {
		if (event.tags.length &gt; 1 &amp;&amp; !confirm(&#x27;Did you mean to paste &#x27; + event.tags.length + &#x27; items?\n\nClick OK to continue. Click cancel to treat it as one item.&#x27;)) {
			this.$input.val(event.value);
			event.preventDefault();
		}
	});

			 */ 
			var pubevt = this.publish(&#x27;BeforePaste&#x27;, {
				event: evt,
				value: value,
				tags: tags
			});
			if (pubevt.isDefaultPrevented()) {
				// don&#x27;t add any tags
				return;
			}
			if (pubevt.tags.length &lt; 2) {				
				// only text here (not a list of tags) so let the user continue typing;
				this.$input.val( this.$input.val()+value );
				this._updateInputSize();
				return;
			}
			// we are going to add each tag
			evt.preventDefault();
			for (i = 0, len = pubevt.tags.length; i &lt; len; i++) {				
				this.add(tags[i]);
			}
			/**
			 * Respond after values are pasted
			 * @event AfterPaste
			 * @param {jQuery.Event} event  The paste event
			 * @param {String} value  The raw value that was pasted
			 * @param {Array} tags  The array of tags that were added (if the value was successfully split on tab, semicolon, or comma)
			 * @example      

	instance.bind(&#x27;AfterPaste&#x27;, function(event) {
		if (event.tags.length &gt; 1) {
			alert(&#x27;You pasted &#x27; + event.tags.length + &#x27; tags&#x27;);
		}
	});

			 */
			this.publish(&#x27;AfterPaste&#x27;, {
				event: evt,
				value: value,
				tags: pubevt.tags
			});
		},
		/**
		 * Handle UP key on this.$input
		 * @method _key_UP
		 * @param {Event} evt  The keydown event
		 */
		_key_UP: function(evt) {
			evt.preventDefault();
			// unfocus any focused tags
			this.unfocusTag();
			// move selection up in suggestion box
			this.moveSelection(&#x27;up&#x27;);     
		},
		/**
		 * Handle DOWN key on this.$input
		 * @method _key_DOWN
		 * @param {Event} evt  The keydown event
		 */   
		_key_DOWN: function(evt) {
			evt.preventDefault();
			// unfocus any focused tags
			this.unfocusTag();
			if (this.isSuggestBoxOpen()) {
				// move selection down in suggestion box
				this.moveSelection(&#x27;down&#x27;);     
			}
		},
		/**
		 * Handle BACKSPACE key on this.$input
		 * @param {Event} evt  The keydown event
		 */   
		_key_BACKSPACE: function(evt) {
			var $lastTag;
			this.$currentItem = null;
			if (this._isCursorAtStart()) {
				if (this.options.multiselect &amp;&amp; this.tags.length &gt; 0) {
					evt.preventDefault();
					$lastTag = this.tags[this.tags.length-1].$tag;
					if (this.$focusedTag &amp;&amp; $lastTag &amp;&amp; this.$focusedTag[0] == $lastTag[0]) {
						this.remove($lastTag);
					}
					else if ($lastTag) {
						this.$focusedTag = $lastTag;
						$lastTag.addClass(&#x27;sugg-focused&#x27;);
					}
				}
				this.closeSuggestBox();
			}
			else {
				// update suggestions
				this._key_other(evt);
			}
		},
		/**
		 * Handle TAB and COMMA and SEMICOLON key on this.$input
		 * @param {Event} evt  The keydown event
		 */   
		_key_TAB_COMMA: function(evt) {
			if (evt.which == 9) { // tab
				if (this.$input.val() === &#x27;&#x27;) {
					// go ahead and tab to next field
					return;
				}
			}
			// tab or comma or semicolon
			evt.preventDefault();
			if (this.$input.val() === &#x27;&#x27;) {
				// no value so don&#x27;t create a new tag
				return;
			}
			this.$currentItem = null;
			this.add(this.$input.val());
			if (this.options.multiselect) {
				this.$input.val(&#x27;&#x27;);
			}
			this.closeSuggestBox();
		},
		/**
		 * Handle ESC key on this.$input
		 * @param {Event} evt  The keydown event
		 */   
		_key_ESC: function(evt) {
			this.closeSuggestBox();     
		},
		/**
		 * Handle ENTER key on this.$input
		 * @param {Event} evt  The keydown event
		 */
		_key_ENTER: function(evt) {
			if (this.$currentItem) {
				// add the item that was selected via arrow or hover
				var record = this.$currentItem.data(&#x27;tag-record&#x27;);
				this.add(record[this.options.valueProperty], record[this.options.labelProperty], this.$currentItem);
				if (this.options.multiselect) {
					this.$input.val(&#x27;&#x27;);
				}
				this.closeSuggestBox();
				this.$currentItem = null;
			}
			if (!this.options.submitOnEnter) {
				// don&#x27;t let form submit
				evt.preventDefault();
			}     
		},
		/**
		 * Handle other keys (e.g. printable characters) on this.$input
		 * @param {Event} evt  The keydown event
		 */   
		_key_other: function(evt) {
			// abort any outstanding xhr requests and clear timeout from key delay
			this.abortFetch();
			// clear key delay
			clearTimeout(this.timeoutHandle);
			// remove suggestion box selection
			this.$currentItem = null;
			// unfocus any tags selected for deletion
			this.unfocusTag();
			// start the timeout
			this.timeoutHandle = setTimeout(this.suggestIfNeeded, this.options.keyDelay || 0);      
		},
		/**
		 * Handler for form submission
		 * 
		 * @param {jQuery} jqEvent  The submit event
		 */
		_onSubmit: function(jqEvent) {
			/**
			 * Respond before form is submitted and before Suggester adds on submit
			 * @event BeforeSubmit
			 * @param {jQuery.Event}  The jQuery-wrapped browser event
			 * @param {HTMLFormElement} form   The input&#x27;s form (same as this.$form)
			 * @ifprevented  Form will not be submitted
			 * @example      

	instance.bind(&#x27;BeforeSubmit&#x27;, function(event) {
		if (this.$input.val() !== &#x27;&#x27; &amp;&amp; !confirm(&#x27;Are you sure you want to submit this form unfinished?&#x27;)) {
			event.preventDefault();
		}
	});

			 */   
			var evt = this.publish(&#x27;BeforeSubmit&#x27;, {
				event: jqEvent,
				form: this.$form,
				cancelable: true
			});
			// cancel form submission
			if (evt.isDefaultPrevented()) {
				jqEvent.preventDefault();
				return;
			}
			if (this.options.addOnSubmit) {
				if (this.$input.val() !== &#x27;&#x27;) {
					this.$currentItem = null;
					this.add(this.$input.val());
					if (this.options.multiselect) {
						this.$input.val(&#x27;&#x27;);
					}
					this.closeSuggestBox();
				}
			}
		},
		/**
		 * The handler function that is passed to $.ajax({beforeSend:...}) to alter XHR if needed
		 * @method _beforeFetch
		 * @param {jqXHR} jqXHR  The jQuery XHR object (see http://api.jquery.com/jQuery.ajax/#jqXHR)
		 */
		_beforeFetch: function(jqXHR) {
			/**
			 * A chance to access the jqXHR before the ajax request has been sent
			 * @event BeforeFetch
			 * @param {jqXHR} jqXHR  the jQuery XHR object (see http://api.jquery.com/jQuery.ajax/#jqXHR)
			 * @param {String} term   the term that is being searched for
			 * @ifprevented  XHR is aborted
			 * @example

	instance.bind(&#x27;BeforeFetch&#x27;, function(event) {
		event.jqXHR.setRequestHeader(&#x27;something&#x27;,&#x27;something&#x27;);
		event.jqXHR.fail(function() {
			alert(&#x27;ajax call failed&#x27;);
		}).always(function() {
			alert(&#x27;ajax call finished regardless of success or failure&#x27;);
		});
	});
			
			 */
			this._jqXHR = jqXHR;
			var evt = this.publish(&#x27;BeforeFetch&#x27;, {
				jqXHR: this._jqXHR,
				term: this._searchTerm,
				cancelable: true
			});
			if (evt.isDefaultPrevented()) {
				this.abortFetch();
			}
		},
		/**
		 * Handler passed to $.ajax().done(function(){...}) that handles suggestion data that is returned
		 * @method _afterFetch
		 * @param {Array} records  The Array of record objects returned from the XHR
		 */
		_afterFetch: function(records) {
			/**
			 * @event AfterFetch
			 * @param {jqXHR} jqXHR    The jQuery XHR object (see http://api.jquery.com/jQuery.ajax/#jqXHR)
			 * @param {Object[]} records  The Array of record objects returned from the XHR
			 * @param {String} term     The term that was search for
			 * @ifprevented  Nothing is done with results (i.e. suggestion box is not built and displayed)
			 * @example

	instance.bind(&#x27;AfterFetch&#x27;, function(event) {
		event.data.push({value:&#x27;&#x27;, label:&#x27;Adding a test suggestion at the end&#x27;});
	});
			
			 */   
			var evt = this.publish(&#x27;AfterFetch&#x27;, {
				jqXHR: this._jqXHR,
				records: records,
				term: this._searchTerm,
				cancelable: true
			});
			this._jqXHR = null;
			if (evt.isDefaultPrevented()) {
				return;
			}
			this.handleSuggestions(evt.records);
		},
		/**
		 * Callback used to close the suggestion box when the user clicks off of it
		 * @param {jQuery.Event} evt  The click event
		 */
		_closeOnOutsideClick: function(evt) {
			var $target = $(evt.target);
			if ($target.parents(&#x27;.sugg-widget&#x27;)[0] == this.$widget[0]) {
				return;
			}
			this.closeSuggestBox();
		}, 
		/**
		 * Format a suggestion before display
		 * @method _formatSuggestion
		 * @param {Object} record  The record that was suggested
		 * @param {String} substr  The string that generated the list of suggestions
		 * @return {String}  HTML to use as the item (e.g. &#x27;&lt;li class=&quot;sugg-item&quot;&gt;Suggestion&lt;/li&gt;&#x27;)
		 */
		_formatSuggestion: function(record, substr) {
			var evt, options, label, replacer, replacee, html;
			/**
			 * Call to dynamically inject your own formatting on each suggestion
			 * @event BeforeFormat
			 * @param {Object} record  The record object that is being suggested
			 * @param {String} substr  The part of the string that matches the suggestion search fields
			 * @param {String} html    If you set event.html, it will be used instead of constructing the HTML
			 * @example

	instance.bind(&#x27;BeforeFormat&#x27;, function(event) {
		event.html = &#x27;&lt;li&gt;&#x27; + event.record.label.toUpperCase() + &#x27;&lt;/li&gt;&#x27;;
	});              

			 */
			evt = this.publish(&#x27;BeforeFormat&#x27;, {
				record: record, 
				substr: substr, 
				html:&#x27;&#x27;
			});
			if (evt.html === &#x27;&#x27;) {
				options = this.options;
				label = record[options.valueProperty];
				// handle case insensitive replacements
				replacer = options.caseSensitive ? evt.substr : new RegExp(&#x27;(&#x27; + evt.substr + &#x27;)&#x27;, &#x27;i&#x27;);
				replacee = options.caseSensitive ? evt.substr : &#x27;$1&#x27;;
				// allow replacements of all {record.field} matches in this.listItemTemplate
				evt.html = this.listItemTemplate.replace(/\{record\.(.+?)\}/g, function($0, $1) {
					var replacement = evt.record[$1];
					if (typeof replacement == &#x27;string&#x27; || !!replacement) {
						if ($1 == options.valueProperty &amp;&amp; options.hightlightSubstring) {           
							replacement = replacement.replace(replacer, &#x27;&lt;strong class=&quot;sugg-match&quot;&gt;&#x27; + replacee + &#x27;&lt;/strong&gt;&#x27;);
						}
						return replacement;
					}
					return &#x27;&#x27;;
				});
			}
			/**
			 * Alter the HTML that has been constructed before it is put into the DOM
			 * @event AfterFormat
			 * @param {Object} record  The record object that is being suggested
			 * @param {String} substr  The part of the string that matches the suggestion search fields
			 * @param {String} html    Change the HTML before it is put into the dom
			 * @example

	instance.bind(&#x27;AfterFormat&#x27;, function(event) {
		event.html; // &lt;li&gt;&lt;strong class=&quot;sugg-match&quot;&gt;Canis&lt;/strong&gt; Major&lt;/li&gt;
		event.html = event.html.replace(/&lt;\/?strong\b/, &#x27;em&#x27;);
	});

			 */			
			evt = this.publish(&#x27;AfterFormat&#x27;, {
				record: evt.record,
				substr: evt.substr,
				html: evt.html
			});
			return evt.html;
		},
		/**
		 * Update the size when this.options.inputSize is &quot;auto&quot;
		 */
		_updateInputSize: function() {
			if (this.options.inputSize == &#x27;auto&#x27;) {         
				this.$input.prop(&#x27;size&#x27;, this.$input.val().length + 2); 
			}
		},
		/**
		 * Set the value of the original input to a comma-delimited set of labels
		 * @method save
		 * @return {String}  The new value
		 */
		save: function() {
			var oldValue = this.$originalInput.val();
			var newValue;
			var vals = [];
			for (var i = 0, len = this.tags.length; i &lt; len; i++) {
				vals.push(this.tags[i].getValue().replace(/,/g, &#x27;\\,&#x27;));
			}
			newValue = vals.join(&#x27;,&#x27;);
			/**
			 * Inject functionality before saving
			 * @event BeforeSave
			 * @param {String} newValue  The value that will be written to the original input (writeable)
			 * @ifcancelled  The original input will not be populated with the new value
			 * @example

	instance.bind(&#x27;BeforeSave&#x27;, function(event) {
		event.newValue += &#x27;!&#x27;;
	});

			 */
			var evt = this.publish(&#x27;BeforeSave&#x27;, {
				cancelable: true,
				oldValue: oldValue,
				newValue: newValue
			});
			if (evt.isDefaultPrevented()) {
				return oldValue;
			}
			this.$originalInput.val(evt.newValue);
			/** 
			 * Do something after saving value to original input
			 * @event AfterSave
			 * @param {String} oldValue  The value before saving
			 * @param {String} newValue  The value that was written to the original input
			 * @example

	instance.bind(&#x27;AfterSave&#x27;, function(event) {
		saveToServer(event.newValue);
	});
      
			 */			
			this.publish(&#x27;AfterSave&#x27;, {
				oldValue: oldValue,
				newValue: evt.newValue
			});
			if (oldValue != evt.newValue) {
				/** 
				 * Fired when the value changes as by adding or removing a tag
				 * @event Change
				 * @param {String} oldValue  The value before saving
				 * @param {String} newValue  The new value
				 * @example

	instance.bind(&#x27;AfterChange&#x27;, function(event) {
		noteSomeChange();
	});

				 */						
				this.publish(&#x27;Change&#x27;, {
					oldValue: oldValue,
					newValue: evt.newValue
				});
			}
			return evt.newValue;
		},
		/**
		 * Given tag text, remove a tag from the internal collection and from the DOM
		 * @method _spliceTag
		 * @param {String} value      The text of the tag
		 * @return {Object}  The record associated with that tag
		 */
		_spliceTag: function(value) {
			var idx = this.getTagIndex(value);      
			if (idx &gt; -1) {
				return this._spliceTagByIdx(idx);
			}
			return undefined;
		},
		/**
		 * Given an array index, remove a tag from the internal collection and from the DOM
		 * @method _spliceTagByIdx
		 * @param {Number} idx  The index position in the internal collection
		 * @return {Suggester.Tag}  The Suggester.Tag object that was removed
		 */   
		_spliceTagByIdx: function(idx) {
			var tag = this.tags[idx];
			var newTags = [];
			var newIndex = 0;
			for (var i = 0, len = this.tags.length; i &lt; len; i++) {
				if (i === idx) {
					this.tags[i].getHidden().remove();
					this.tags[i].getElement().remove();
				}
				else {
					this.tags[i].index = newIndex++;
					newTags.push(this.tags[i]);
				}
			}
			this.tags = newTags;
			return tag;
		},
		/**
		 * Find a tag given value
		 * @method getTagIndex
		 * @param {String} value      The text of the tag
		 * @return {Number}  The index position of the tag in the internal collection or -1 if not found
		 */
		getTagIndex: function(value) {
			var idx = -1, i, len;
			for (i = 0, len = this.tags.length; i &lt; len; i++) {
				if (this.tags[i].getValue() == value) {
					idx = i;
					break;
				}
			}
			return idx;     
		},
		/**
		 * Setup publish/subscribe system that uses jQuery&#x27;s event system. Allows subscribing this way: instance.bind(&#x27;AfterFilter&#x27;, myhandler)
		 * @method _setupPubsub
		 */
		_setupPubsub: function() {
			this.pubsub = $(this);
			this.on = $.proxy(this.pubsub, &#x27;on&#x27;);
			this.off = $.proxy(this.pubsub, &#x27;off&#x27;);
			this.one = $.proxy(this.pubsub, &#x27;one&#x27;);
			this.bind = $.proxy(this.pubsub, &#x27;bind&#x27;);
			this.unbind = $.proxy(this.pubsub, &#x27;unbind&#x27;);
			this.trigger = $.proxy(this.pubsub, &#x27;trigger&#x27;);
			this.triggerHandler = $.proxy(this.pubsub, &#x27;triggerHandler&#x27;);
			// bind listeners passed in the options (e.g. onInitialize)
			for (var name in this.options) {
				if (name.match(/^on[A-Z0-9]/) &amp;&amp; typeof this.options[name] == &#x27;function&#x27;) {
					this.bind(name.slice(2), this.options[name]);
				}
			}
		},
		/**
		 * Given an input element, get the cursor position. Used to determine if backspace key should delete the previous tag
		 * @method _isCursorAtStart
		 * @return {Boolean}  true if the cursor is at the start and no text is selected
		 */
		_isCursorAtStart: function() {
			var selStart = _getSelectionStart(this.$input[0]);
			var selEnd = _getSelectionEnd(this.$input[0]);
			return selStart === 0 &amp;&amp; selEnd === 0;
		}
	};
  
	// cursor helper methods
	// from http://javascript.nwbox.com/cursor_position/cursor.js
	function _getSelectionStart(o) {
		if (o.createTextRange) {
			var r = document.selection.createRange().duplicate();
			r.moveEnd(&#x27;character&#x27;, o.value.length);
			if (r.text === &#x27;&#x27;) {
				return o.value.length;
			}
			return o.value.lastIndexOf(r.text);
		}
		return o.selectionStart;
	}
	function _getSelectionEnd(o) {
		if (o.createTextRange) {
			var r = document.selection.createRange().duplicate();
			r.moveStart(&#x27;character&#x27;, -o.value.length);
			return r.text.length;
		}
		return o.selectionEnd;
	}
  
	//
	// static properties and methods
	//
	$.Suggester.version = &#x27;%VERSION%&#x27;;
	/**
	 * Pass to contructor to subclass (e.g. &#x60;MySuggester.prototype = new $.Suggester($.Suggester.doSubclass)&#x60;)
	 * @var {Object}
	 */
	$.Suggester.doSubclass = {};
	/**
	 * A collection of all the instances
	 * @property {Array} instances
	 * @static
	 */
	$.Suggester.instances = [];
	/**
	 * Add data to all instances
	 * @method addData
	 * @static
	 * @param {Object[]} data  Add more data to all the registered instances
	 * @return {Suggester}
	 */
	$.Suggester.addData = function(data) {
		$.each($.Suggester.instances, function() {
			this.addData(data);
		});
		return this;
	};
	/**
	 * Lightweight event handler to allow keydown to have less overhead (i.e. bypass jQuery&#x27;s event system)
	 */
	$.Suggester.quickBind = document.addEventListener ? 
		function(element, type, handler) {
			element.addEventListener(type, handler, false);
		} :
		function(element, type, handler) {
			element.attachEvent(&#x27;on&#x27;+type, function(evt) {
				evt = evt || window.event;
				evt.preventDefault = function() {
					evt.returnValue = false;
				};
				handler.call(element, evt);
			});
		}
	;
	/**
	 * Create a subclass of Suggester
	 * @method subclass
	 * @static
	 * @param {String} jQueryMethodName  The method name to add to jQuery.fn
	 * @param {Object} [properties]  Additional properties and methods to add to subclass
	 * @return {Function}  The new class object
	 * @example

	var MySuggester = $.Suggester.subclass(&#x27;mysuggester&#x27;, {
		initialize: function($textInput, options) {
			options = options || {};
			this.options.myOption = options.myOptions || &#x27;default&#x27;;
			this.callParent(&#x27;initialize&#x27;, $textInput, options);
		}
	});
	// now call $(selector).mysuggester(options);
		
	 */
	$.Suggester.subclass = function(jQueryMethodName, properties) {
		var Ctor = function() {
			this.initialize.apply(this, Array.prototype.slice.call(arguments));
		};
		Ctor.prototype = new $.Suggester($.Suggester.doSubclass);
		Ctor.prototype.callParent = function(method/*, arg1, arg2, arg3*/) {
			$.Suggester.prototype[method].apply(this, method, Array.prototype.slice.call(arguments, 1));
		};
		Ctor.prototype.applyParent = function(method, args) {
			$.Suggester.prototype[method].apply(this, method, args);
		};
		$.extend(Ctor.prototype, properties || {});
		makePlugin(jQueryMethodName, Ctor);
		return Ctor;
	};
	function makePlugin(name, Ctor) {
		$.fn[name] = function(options) {    
			// handle where first arg is method name and additional args should be passed to that method
			if (typeof options == &#x27;string&#x27; &amp;&amp; this.data(&#x27;SuggesterInstance&#x27;) instanceof $.Suggester &amp;&amp; typeof this.data(&#x27;SuggesterInstance&#x27;)[options] == &#x27;function&#x27;) {
				var args = Array.prototype.slice.call(arguments, 1);
				return this.data(&#x27;SuggesterInstance&#x27;)[options].apply(this.data(&#x27;SuggesterInstance&#x27;), args);
			}
			if (this.data(&#x27;SuggesterInstance&#x27;)) {
				return this;
			}
			// otherwise create new $.Suggester instance but return the jQuery instance
			return this.each(function() {     
				var $elem = $(this);
				var instance = new Ctor($elem, options);
				$elem.data(&#x27;SuggesterInstance&#x27;, instance);
			});
		};
	}
	makePlugin(&#x27;suggester&#x27;, $.Suggester);
	$.Suggester.Tag = function() {
		this.initialize.apply(this, Array.prototype.slice.call(arguments));
	};  
	$.Suggester.Tag.prototype = {
		/**
		 * @class Tag
		 * @constructor
		 * @namespace Suggester
		 * @param {Object} properties
		 *   @param {Suggester} properties.suggester  The Suggester to which this tag belongs
		 *   @param {String} properties.value  The value of the tag
		 *   @param {String} properties.label  The display text of the tag
		 *   @param {Number} properties.index  The index relative to other tags
		 *   @param {jQuery} properties.$hidden  The hidden input element
		 *   @param {jQuery} properties.$tag  The tag element
		 *   @param {Object|undefined} properties.record  The record corresponding to this tag, if any
		 */
		initialize: function(properties) {
			$.extend(this, properties);
		},
		/**
		 * The Suggester to which this tag belongs
		 * @property {Suggester} suggester
		 */
		/**
		 * The value of the tag
		 * @property {String} value
		 */
		/**
		 * The display text if the tag
		 * @property {String} label
		 */
		/**
		 * The index relative to other tags
		 * @property {Number} index
		 */
		/**
		 * The hidden input element
		 * @property {jQuery} $hidden
		 */
		/**
		 * The tag elements
		 * @property {jQuery} $tag
		 */
		/**
		 * The record corresponding to this tag, if any
		 * @property {Object|undefined}
		 */
		
		/**
		 * Get the Suggester widget to which this tag belongs
		 * @method getWidget
		 * @return {Suggester}
		 */
		getWidget: function() {
			return this.suggester;
		},
		/**
		 * Remove this tag from the tag collection
		 * @method remove
		 * @return {Suggester.Tag}
		 * @chainable
		 */
		remove: function() {
			this.suggester.remove(this.value);
			return this;
		},
		/**
		 * Get thee index of this tag relative to others
		 * @method getIndex
		 * @return {Number}
		 */
		getIndex: function() {
			return this.index;
		},
		/**
		 * Get the hidden value of this tag
		 * @method getValue
		 * @return {String}
		 */
		getValue: function() {
			return this.value;
		},
		/**
		 * Set the hidden value of this tag
		 * @param {String} value  The new value
		 * @return {Suggester.Tag}
		 * @chainable
		 */
		setValue: function(value) {
			this.value = value;
			this.$hidden.val(value);
			this.suggester.save();
			return this;
		},
		/**
		 * Get the visible label of this tag
		 * @method getLabel
		 * @return {String}
		 */
		getLabel: function() {
			return this.label;
		},
		/**
		 * Set the visibile label of this tag
		 * @method setLabel
		 * @return {Suggester.Tag}
		 * @chainable
		 */
		setLabel: function(label) {
			this.label = label;
			this.$tag.text(label);
			return this;
		},
		/**
		 * Get the hidden value of the tag
		 * @method getHidden
		 * @return {String}
		 */
		getHidden: function() {
			return this.$hidden;
		},
		/**
		 * Get the tag element
		 * @method getElement
		 * @return {jQuery}
		 */
		getElement: function() {
			return this.$tag;
		},
		/**
		 * Get the record that generated this tag, if any
		 * @return {Object|undefined}
		 */
		getRecord: function() {
			return this.record;
		}
	};
}));  

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
